# Furina Betting Games
- A project that aims to simply recreate 2 simple betting games, played through the command line, preferably in 1 file, and in as many programming languages as possible.
- The goal is to have a vague but basic understanding of each language's syntax and properties, as well as some experience scripting in all of them. Also, have fun with it!
- Most of these code were tested and ran using online compliers because I don't have that much space on my laptop for 50 languages. Sorry.
- Game engine languages are banned.

# Next language: Rust

# This project has been written in 7 languages
In chronological order, they are: C++, Python, C#, C, Haskell, Javascript, MIPS Assembly

My experience/things I've learned with each language:
1. C++: I started this project with C++ because it was the language being taught in my first year of university, and I got inspired after a friend of mine made a little gambling game in C and showed it to me. I was (and am still) passionate about Furina, and so I made a little CLI game. I thought about porting the game to different languages, as a challenge, out of curiosity of their various differences, and for fun. This one is made inside of a single main function with a while loop. It's not good practice, I know, but it is the first attempt.
2. Python: Porting this was a piece of cake, since Python's syntax is dead simple (the hardest part was installing Python). Keeping the exact same overall program structure, I optimized some stuff using shorthand if-else, resulting in extremely few lines.
3. C#: Ah, my first love since I was making games with Unity in 2022. I hadn't learned too much about interfaces, so it was such a simple port. However, 1Kill2Steal had inspired me to use more good programming practices, so I separated the features into individual functions, declared some error messages at the top, and I also added various comments. To complete it, I added a C# exclusive ending to the game.
4. C: At first, I thought C was just C++ without some features (like built-in string classes and some libraries). It wasn't until in second year of university did I learn about manual memory management, such as pointers and mallocs, and I gained an appreciation for garbage collection features of modern-day languages, since it prevents the hassle of memory leaks. Anyway, I remade the game using pointers to be more performant, and also separated the games into void functions, unlike the C++ and Python ones.
5. Haskell: An absolute nightmare to get working. Took an entire day of head-scratching and praying for help in the Haskell discord channel. It did teach me quite a bit amount immutability and some functional programming paradigms.
6. Javascript: The day after Haskell, I have had enough of the headache, and I decided to chill with Javascript, known as the loosely-typed, hard-to-maintain language, whose frameworks are constantly changing. For this language, I was surprised at how similar its syntax was to C#. I then went on to making a Vietnamese connect-the-word game using raw Javascript, HTML and CSS with my friends.
7. MIPS Assembly: I was in the process of learning Assembly for university, and I thought "Hey, the Furina Betting Games is a great way to test if I knew how to implement all the essential features of a programming language. Let's do it!". Since I already built an 8-bit computer and passed a couple Assembly challenges in Turing Complete, I was already quite familiar with Assembly, and it only took me a little over 2 hours to port the game over. I'm quite satisfied with the readable result, and learning Assembly really does give you a great appreciation for higher level languages.
